"""
CYCLE 320: Forward Cymatics (Emitters -> Pattern)
Objective: Simulate how a set of emitters creates a density pattern on a 2D grid.
Hypothesis: Understanding the forward model is crucial for building the inverse solver.
Author: Aldrin Payopay (aldrin.gdf@gmail.com)
Co-Authored-By: Gemini 2.5 Flash (MOG Pilot)
"""
import numpy as np
import json
import os
import sys

# Ensure project root is in path for TargetField import
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from experiments.cycle319_target_field import TargetField # Import our TargetField class

class Emitter:
    """Represents a point source generating a wave."""
    def __init__(self, x: float, y: float, frequency: float, phase: float, amplitude: float = 1.0):
        self.x = x
        self.y = y
        self.frequency = frequency
        self.phase = phase # in radians
        self.amplitude = amplitude

    def to_dict(self):
        return {
            "x": self.x, "y": self.y,
            "frequency": self.frequency, "phase": self.phase,
            "amplitude": self.amplitude
        }

class CymaticSimulation:
    """Simulates the interference pattern generated by multiple emitters on a 2D grid."""
    def __init__(self, width: int, height: int, emitters: list[Emitter], wave_speed: float = 1.0):
        self.width = width
        self.height = height
        self.emitters = emitters
        self.wave_speed = wave_speed # For simplicity, assumes uniform medium

    def calculate_density_field(self) -> np.ndarray:
        """
        Calculates the density field based on the superposition of waves from emitters.
        A simple model: D(x,y) = Sum_i (Amplitude_i * cos(k*distance_i + phase_i))
        where k = 2*pi*frequency / wave_speed
        """
        density_field = np.zeros((self.height, self.width), dtype=float)
        
        for y in range(self.height):
            for x in range(self.width):
                total_amplitude = 0.0
                for emitter in self.emitters:
                    distance = np.sqrt((x - emitter.x)**2 + (y - emitter.y)**2)
                    
                    # Wave number k = 2 * pi * f / v
                    k = 2 * np.pi * emitter.frequency / self.wave_speed
                    
                    # Superposition of cosine waves
                    total_amplitude += emitter.amplitude * np.cos(k * distance + emitter.phase)
                
                # Normalize density to be between 0 and 1 (or -1 and 1)
                # For visualization, let's keep it simple: higher amplitude = higher density
                density_field[y, x] = (total_amplitude + len(self.emitters) * np.max([e.amplitude for e in self.emitters])) / (2 * len(self.emitters) * np.max([e.amplitude for e in self.emitters])) # scale to 0-1
                density_field[y, x] = np.clip(density_field[y, x], 0.0, 1.0) # Ensure within bounds
                
        return density_field

def main():
    print("CYCLE 320: FORWARD CYMATICS (EMITTERS -> PATTERN)")
    print("==================================================")

    width, height = 50, 25

    # --- Scenario 1: Single Emitter (Simple Concentric Waves) ---
    print("\n--- Scenario 1: Single Emitter ---")
    emitter1 = Emitter(x=25, y=12, frequency=0.5, phase=0.0, amplitude=1.0)
    sim1 = CymaticSimulation(width, height, [emitter1])
    density_field1 = sim1.calculate_density_field()
    
    # Use TargetField to display
    target_field1 = TargetField(width, height, default_density=0.0)
    target_field1.field = density_field1 # Direct assignment for visualization
    target_field1.display(scale=1) # scale=1 for better resolution

    # --- Scenario 2: Two Emitters (Interference Pattern) ---
    print("\n--- Scenario 2: Two Emitters (Interference) ---")
    emitter2_1 = Emitter(x=15, y=12, frequency=0.5, phase=0.0, amplitude=1.0)
    emitter2_2 = Emitter(x=35, y=12, frequency=0.5, phase=np.pi, amplitude=1.0) # Out of phase
    sim2 = CymaticSimulation(width, height, [emitter2_1, emitter2_2])
    density_field2 = sim2.calculate_density_field()
    
    target_field2 = TargetField(width, height, default_density=0.0)
    target_field2.field = density_field2
    target_field2.display(scale=1)

    # --- Scenario 3: Different Frequencies (Complex Pattern) ---
    print("\n--- Scenario 3: Different Frequencies ---")
    emitter3_1 = Emitter(x=10, y=10, frequency=0.3, phase=0.0, amplitude=1.0)
    emitter3_2 = Emitter(x=40, y=15, frequency=0.7, phase=np.pi/2, amplitude=1.0)
    sim3 = CymaticSimulation(width, height, [emitter3_1, emitter3_2])
    density_field3 = sim3.calculate_density_field()
    
    target_field3 = TargetField(width, height, default_density=0.0)
    target_field3.field = density_field3
    target_field3.display(scale=1)

    # Save results summary (for validation check)
    results_summary = {
        "cycle": 320,
        "width": width,
        "height": height,
        "scenario1_mean_density": np.mean(density_field1),
        "scenario2_mean_density": np.mean(density_field2),
        "scenario3_mean_density": np.mean(density_field3),
        "status": "Forward Cymatics simulation operational and producing distinct patterns"
    }

    os.makedirs("experiments/results", exist_ok=True)
    with open("experiments/results/c320_forward_cymatics_2d.json", "w") as f:
        json.dump(results_summary, f, indent=2)

    print("\n--- C320 Complete ---")

if __name__ == "__main__":
    main()
