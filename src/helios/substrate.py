"""
HELIOS Substrate Interface
The Universal Adapter for wave-bearing media.
Enables the Solver to operate on Acoustics, Fluids, and Social Dynamics agnostically.
"""
from abc import ABC, abstractmethod
import numpy as np

class SubstrateInterface(ABC):
    """
    Abstract Base Class for all physical substrates.
    Defines the interface that the Inverse Solver (Pilot) expects.
    """
    
    def __init__(self, width: int, height: int, wave_speed: float, damping: float):
        self.width = width
        self.height = height
        self.wave_speed = wave_speed
        self.damping = damping
        
    @abstractmethod
    def propagate(self, emitters: list) -> np.ndarray:
        """
        Calculates the steady-state field generated by the emitters.
        Must return a 2D numpy array of dimensions (height, width).
        """
        pass

    @abstractmethod
    def get_properties(self) -> dict:
        """Returns physical constants of the substrate."""
        pass

class NRMSubstrate(SubstrateInterface):
    """
    The original NRM simulation (Low speed, low damping).
    Represents 'Abstract Cognitive Space' or 'Slow Light'.
    """
    def __init__(self, width=64, height=64):
        super().__init__(width, height, wave_speed=1.0, damping=0.01)
        
    def propagate(self, emitters: list) -> np.ndarray:
        y, x = np.mgrid[0:self.height, 0:self.width]
        field = np.zeros((self.height, self.width))
        
        for e in emitters:
            dist = np.sqrt((x - e.x)**2 + (y - e.y)**2)
            k = 2 * np.pi * e.frequency / self.wave_speed
            # Standard wave equation
            field += e.amplitude * np.cos(k * dist + e.phase) * np.exp(-self.damping * dist)
            
        # Normalize 0-1 for NRM
        max_amp = sum(e.amplitude for e in emitters) or 1.0
        return np.clip((field + max_amp) / (2 * max_amp), 0.0, 1.0)

    def get_properties(self):
        return {"type": "NRM", "v": self.wave_speed, "gamma": self.damping}

class AcousticSubstrate(SubstrateInterface):
    """
    Acoustic Levitation Simulator (High speed, specific damping).
    Real-world physics: v = 343 m/s.
    """
    def __init__(self, width_mm=100, height_mm=100, resolution_mm=1):
        # Grid represents mm, not abstract units
        w_pixels = int(width_mm / resolution_mm)
        h_pixels = int(height_mm / resolution_mm)
        super().__init__(w_pixels, h_pixels, wave_speed=343.0, damping=0.001) # Air has low damping
        self.resolution = resolution_mm
        
    def propagate(self, emitters: list) -> np.ndarray:
        # Scale inputs: Emitter x,y are in GRID coordinates
        # But physics calculation needs REAL WORLD distances (meters)
        
        y_grid, x_grid = np.mgrid[0:self.height, 0:self.width]
        x_m = x_grid * (self.resolution / 1000.0)
        y_m = y_grid * (self.resolution / 1000.0)
        
        field = np.zeros((self.height, self.width))
        
        for e in emitters:
            # Emitter pos is in grid coords
            ex_m = e.x * (self.resolution / 1000.0)
            ey_m = e.y * (self.resolution / 1000.0)
            
            dist_m = np.sqrt((x_m - ex_m)**2 + (y_m - ey_m)**2)
            
            # k = 2 * pi * f / v
            # Frequencies for levitation are typically 40kHz (40000 Hz)
            # If emitter.frequency is normalized 0-1, we map it to 30k-50k
            real_freq = 30000 + (e.frequency * 20000) 
            
            k = 2 * np.pi * real_freq / self.wave_speed
            
            # Acoustic Pressure Field
            # Note: Levitation relies on Standing Waves (Gorkov Potential)
            # which is proportional to <p^2>. For now, we map Pressure p.
            field += e.amplitude * np.cos(k * dist_m + e.phase)
            
        # Normalize for visualization (Pressure can be negative)
        # We want to visualize the Nodes (Low Pressure) vs Antinodes (High Pressure)
        # Levitation happens at Nodes.
        return field # Return raw pressure for analysis

    def get_properties(self):
        return {"type": "Acoustic", "v": self.wave_speed, "gamma": self.damping}
